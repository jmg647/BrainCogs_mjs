function subjects = analyzeTaskStrategy(subjects)

for i = 1:numel(subjects)
    for j = 1:numel(subjects(i).sessions)
        
        % Trial masks for predictors and response variable
        trials = subjects(i).trials(j);
        rightCue = trials.rightCue(~trials.omit)';%Exclude omissions
        rightChoice = trials.right(~trials.omit)'; %Exclude omissions
        %Exclude first trial
        rightCue = rightCue(2:end);
        rightPriorChoice = rightChoice(1:end-1);
        rightChoice = rightChoice(2:end);
        
        %Additional masks for conflict trials
        conflict = trials.conflict(~trials.omit);
        correct = trials.correct(~trials.omit);
        pCorrect_conflict = mean(trials.conflict(trials.correct));
        pConflict = mean(conflict);
        
        %Logistic regression of Choices based on Sensory Cues and Prior Choice
<<<<<<< Updated upstream
        dummyCode = @(X) 2*(X-0.5);
        predictors = dummyCode([rightCue, rightPriorChoice]);
=======
        predictors = [rightCue, rightPriorChoice];
>>>>>>> Stashed changes
        response = rightChoice;
        if isempty(predictors) || isempty(response)
            [B, stats] = assignNaN();
        else
            lastwarn(''); % Clear last warning message
            [B,~,stats] = glmfit(predictors,response,'binomial','link','logit');
        end
        [warnMsg, warnId] = lastwarn;
        
        %Get condition number for GLM
        X = [ones(size(predictors,1),1),predictors]; %Design matrix
        moment = X'*X; %Moment matrix of regressors
        condNum = cond(moment); %Condition number
        
<<<<<<< Updated upstream
        %For ill-conditioned data
        if any([isempty(predictors),isempty(response)]) %any(isnan(stats.p)) %~exist('B') || 
            [B, stats] = assignNaN();
            predictors = NaN;
            response = NaN;
=======
        %**Temporary: a couple sessions have <3 trials**
        %   future: prior exclusion of early sessions with few trials (rare)
        if any([isempty(predictors),isempty(response)]) 
            B = NaN(3,1);
            stats = struct('beta',NaN(3,1),'se',NaN(3,1),'p',NaN(3,1));
            B, stats.beta, stats.se, stats.p]
            [predictors, response] = deal(NaN);
>>>>>>> Stashed changes
        end
   
        %Assign into output structures
        subjects(i).sessions(j).betaCues= B(2);
        subjects(i).sessions(j).betaChoice = B(3);
        subjects(i).sessions(j).bias = B(1);
        
        Stats = @(term) struct(...
            'beta', stats.beta(term),...
            'se',stats.beta(term) + [-1,1]*stats.se(term),... %B -/+ SE
            'p',stats.p(term));
        
        subjects(i).sessions(j).glm = struct(...
<<<<<<< Updated upstream
            'cueSide',Stats(2),'priorChoice',Stats(3),'bias',Stats(1),...
            'R_predictors',min(corrcoef(predictors),[],'all'),...
            'R_cue_choice',min(corrcoef([rightCue,response]),[],'all'),...
            'R_priorChoice_choice',min(corrcoef([rightPriorChoice,response]),[],'all'),...
            'N',numel(response),'pRightChoice',mean(rightPriorChoice),'pRightCue',mean(rightCue),...
            'pConflict',pConflict, pCorrect_conflict
=======
            'bias',Stats(1),'cueSide',Stats(2),'priorChoice',Stats(3),...
            'R_predictors', min(corrcoef(predictors),[],'all'),... %Excludes diagonal ones
            'R_cue_choice', min(corrcoef([rightCue,response]),[],'all'),...
            'R_priorChoice_choice', min(corrcoef([rightPriorChoice,response]),[],'all'),...
            'N',numel(response),...
            'pRightChoice',mean(rightPriorChoice),'pRightCue',mean(rightCue),...
>>>>>>> Stashed changes
            'conditionNum',condNum,...
            'warning',struct('msg',warnMsg,'ID',warnId));
        
        clearvars B stats
                
    end
end

% msg = arrayfun(@(sessionID) subjects(1).sessions(sessionID).glm.warning.msg,1:numel(subjects(1).sessions),'UniformOutput',false);